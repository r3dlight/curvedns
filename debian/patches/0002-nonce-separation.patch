From 855e439db85ef9517e83f2b20ea8ece4a2fc2fb7 Mon Sep 17 00:00:00 2001
From: Jan Mojzis <jan.mojzis@gmail.com>
Date: Thu, 23 Jun 2016 10:57:40 +0200
Subject: nonce separation

---
 curvedns.c |  16 ++++++
 dnscurve.c |   4 +-
 misc.c     | 161 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----
 misc.h     |   5 +-
 4 files changed, 170 insertions(+), 16 deletions(-)

--- a/curvedns.c
+++ b/curvedns.c
@@ -65,10 +65,14 @@
 	debug_log(DEBUG_FATAL, " [CURVEDNS_TCP_TIMEOUT]\n\tNumber of seconds before TCP session to client times out (default: 60.0)\n");
 	debug_log(DEBUG_FATAL, " [CURVEDNS_SHARED_SECRETS]\n\tNumber of shared secrets that can be cached (default: 5000)\n");
 	debug_log(DEBUG_FATAL, " [CURVEDNS_DEBUG]\n\tDebug level, 1: fatal, 2: error, 3: warning, 4: info, 5: debug (default: 2)\n");
+	debug_log(DEBUG_FATAL, " [CURVEDNS_NONCE_KEY]\n\tThe hexidecimal representation of the nonce's secret key ((default: [none])\n");
+	debug_log(DEBUG_FATAL, " [CURVEDNS_NONCE_START]\n\tNonce starting bits (default: [none]):\n\t the  first of four servers '00'\n\t the second of four servers '01'\n\t the  third of four servers '10'\n\t ...\n");
 	return 1;
 }
 
 static int getenvoptions() {
+	char *tmpstring = (char *)0;
+	unsigned char tmpnoncekey[16]; int flagnoncekey = 0;
 	int tmpi;
 	double tmpd;
 	char ip[INET6_ADDRSTRLEN];
@@ -134,6 +138,18 @@
 		debug_log(DEBUG_INFO, "shared secret cache: %d positions\n", global_shared_secrets);
 	}
 
+        if (misc_getenv_noncekey("CURVEDNS_NONCE_KEY", 0, tmpnoncekey)) {
+                flagnoncekey = 1;
+        }
+
+        if (misc_getenv_string("CURVEDNS_NONCE_START", 0, &tmpstring)) {
+		debug_log(DEBUG_FATAL, "nonce start string is '%s'\n", tmpstring);
+        }
+        else {
+		debug_log(DEBUG_INFO, "nonce start string is (null)\n");
+        }
+        misc_crypto_nonce_init(tmpstring, tmpnoncekey, flagnoncekey);
+
 	return 1;
 }
 
--- a/dnscurve.c
+++ b/dnscurve.c
@@ -368,7 +368,7 @@
 	// Set everything for the encryption step:
 	memcpy(fullnonce, packet->nonce, 12);
 	time = ev_now(event_default_loop);
-	misc_crypto_nonce(fullnonce + 12, &time, sizeof(time));
+	misc_crypto_nonce(fullnonce + 12);
 
 	result = dnscurve_get_shared_secret(packet);
 	if ((result < 0) || packet->ispublic) {
@@ -441,7 +441,7 @@
 	// Now write the streamline header:
 	memcpy(fullnonce, packet->nonce, 12);
 	time = ev_now(event_default_loop);
-	misc_crypto_nonce(fullnonce + 12, &time, sizeof(time));
+	misc_crypto_nonce(fullnonce + 12);
 
 	result = dnscurve_get_shared_secret(packet);
 	if ((result < 0) || packet->ispublic) {
--- a/misc.c
+++ b/misc.c
@@ -34,6 +34,9 @@
  * $Revision$
  */
 
+#include <time.h>
+#include <sys/time.h>
+
 #include "misc.h"
 #include "ip.h"
 
@@ -101,6 +104,33 @@
 	return 1;
 }
 
+int misc_getenv_noncekey(const char *env, int mandatory, uint8_t *result) {
+        char *ptr;
+        if (!(ptr = misc_getenv(env, mandatory))) {
+                return 0;
+        }
+
+        if (strlen(ptr) != 32) {
+                debug_log(DEBUG_FATAL, "nonce key in $%s must be 32 bytes long\n", env);
+                return 0;
+        }
+
+        if (!misc_hex_decode(ptr, result)) {
+                debug_log(DEBUG_FATAL, "nonce key in $%s appears to be invalid\n", env);
+                return 0;
+        }
+        return 1;
+}
+
+int misc_getenv_string(const char *env, int mandatory, char **result) {
+	char *ptr;
+	if (!(ptr = misc_getenv(env, mandatory))) {
+		return 0;
+	}
+	*result = ptr;
+	return 1;
+}
+
 int misc_char_hex(char in, uint8_t *out) {
 	if ((in >= '0') && (in <= '9')) {
 		*out = in - '0';
@@ -221,20 +251,125 @@
 	return out[--outleft] % n;
 }
 
+
+static void misc_uint32_pack(unsigned char *y, uint32_t x) {
+        *y++ = x; x >>= 8;
+        *y++ = x; x >>= 8;
+        *y++ = x; x >>= 8;
+        *y++ = x;
+}
+
+static uint32_t misc_uint32_unpack(const unsigned char *x) {
+        uint32_t result;
+        result = x[3];
+        result <<= 8; result |= x[2];
+        result <<= 8; result |= x[1];
+        result <<= 8; result |= x[0];
+        return result;
+}
+
+
+static void misc_crypto_nonce_encrypt(unsigned char *out, uint64_t in, const unsigned char *k) {
+
+        int i;
+        uint32_t v0, v1, k0, k1, k2, k3;
+        uint32_t sum = 0;
+        uint32_t delta=0x9e3779b9;
+
+        v0 = in; in >>= 32;
+        v1 = in;
+        k0 = misc_uint32_unpack(k + 0);
+        k1 = misc_uint32_unpack(k + 4);
+        k2 = misc_uint32_unpack(k + 8);
+        k3 = misc_uint32_unpack(k + 12);
+
+        for (i = 0; i < 32; i++) {
+                sum += delta;
+                v0 += ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);
+                v1 += ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);
+        }
+        misc_uint32_pack(out + 0, v0);
+        misc_uint32_pack(out + 4, v1);
+        return;
+}
+
+static uint64_t misc_nanoseconds(void) {
+
+    struct timeval t;
+
+    gettimeofday(&t,(struct timezone *) 0);
+    return t.tv_sec * 1000000000LL + t.tv_usec * 1000LL;
+}
+
+
+static int flagnoncekey;
+static unsigned char noncekey[16];
+static uint64_t noncecounter = 0;
+static uint8_t noncemask[4] = {0xff, 0xff, 0xff, 0xff};
+static uint8_t noncedata[4] = {0, 0, 0, 0};
+void misc_crypto_nonce_init(char *ns, unsigned char nk[16], int fk) {
+
+        int i;
+
+        noncecounter = misc_nanoseconds();
+
+        if (!ns) ns = "";
+        i = 0;
+        while(i < 32) {
+            if (!ns[i]) break;
+            if (ns[i] != '0' && ns[i] != '1') break;
+
+            noncemask[i/8] = noncemask[i/8] * 2;
+            noncedata[i/8] = noncedata[i/8] * 2 +  ns[i] - '0';
+            ++i;
+        }
+        while(i < 32) {
+            noncemask[i/8] = noncemask[i/8] * 2 + 1;
+            noncedata[i/8] = noncedata[i/8] * 2;
+            ++i;
+        }
+
+        flagnoncekey = fk;
+        if (flagnoncekey) {
+            memcpy(noncekey, nk, sizeof noncekey);
+        }
+}
+
 // Make sure sizeof(nonce) >= 12
-void misc_crypto_nonce(uint8_t *nonce, void *time, int len) {
-	// We would like the first 64 bits to be time based.
-	// The last 32 bits can be random.
-
-	// XXX: but dirty solution, nicer way?
-	if (len < 8) {
-		memcpy(nonce, time, len);
-	} else {
-		memcpy(nonce, time, 8);
-		len = 8;
-	}
-	for ( ; len < 12; len++)
-		nonce[len] = misc_crypto_random(256);
+void misc_crypto_nonce(uint8_t *nonce) {
+
+        uint64_t x, newnoncecounter;
+
+        for(x = 0; x < 4; ++x) {
+            nonce[x] = misc_crypto_random(256);
+            nonce[x] &= noncemask[x];
+            nonce[x] += noncedata[x];
+        }
+
+        ++noncecounter;
+        newnoncecounter = misc_nanoseconds();
+        if (newnoncecounter > noncecounter) {
+            noncecounter = newnoncecounter;
+        }
+        x = noncecounter;
+
+        if (flagnoncekey) {
+            misc_crypto_nonce_encrypt(nonce + 4, x, noncekey);
+        }
+        else {
+            nonce[4] = x; x >>= 8;
+            nonce[5] = x; x >>= 8;
+            nonce[6] = x; x >>= 8;
+            nonce[7] = x; x >>= 8;
+            nonce[8] = x; x >>= 8;
+            nonce[9] = x; x >>= 8;
+            nonce[10] = x; x >>= 8;
+            nonce[11] = x;
+        }
+
+        debug_log(DEBUG_DEBUG, "misc_crypto_nonce(): %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n", 
+                nonce[0], nonce[1], nonce[2], nonce[3], nonce[4],nonce[5], nonce[6], nonce[7],
+                nonce[8], nonce[9], nonce[10], nonce[11]);
 }
 
 static const uint8_t kValues[] = {
--- a/misc.h
+++ b/misc.h
@@ -52,6 +52,8 @@
 extern int misc_getenv_int(const char *, int, int *);
 extern int misc_getenv_double(const char *, int, double *);
 extern int misc_getenv_key(const char *, int, uint8_t *);
+extern int misc_getenv_noncekey(const char *, int, uint8_t *);
+extern int misc_getenv_string(const char *, int, char **);
 
 extern int misc_char_hex(char, uint8_t *);
 extern int misc_hex_char(uint8_t, char *);
@@ -65,6 +67,7 @@
 
 extern int misc_crypto_random_init();
 extern unsigned int misc_crypto_random(unsigned int);
-extern void misc_crypto_nonce(uint8_t *, void *, int);
+extern void misc_crypto_nonce(uint8_t *);
+extern void misc_crypto_nonce_init(char *, unsigned char *, int);
 
 #endif /* MISC_H_ */
